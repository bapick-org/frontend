<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>밥픽 - 캘린더</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Inter:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Noto Sans KR', 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #ffffff;
            padding-bottom: 80px;
        }

        .bg-custom-point {
            background-color: #FF7242 !important;
        }

        .text-custom-point {
            color: #FF7242 !important;
        }

        .border-custom-today {
            border-color: #FF7242 !important;
        }

        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }

        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .scroll-snap-y-mandatory {
            scroll-snap-type: y mandatory;
        }

        .scroll-snap-align-center {
            scroll-snap-align: center;
        }

        .swipe-container {
            position: relative;
            overflow: hidden;
            border-radius: 0.75rem;
        }

        .swipe-content {
            position: relative;
            z-index: 10;
            transition: transform 0.3s ease;
            touch-action: pan-y;
            background-color: #F9E9CC;
        }

        .swipe-actions {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 160px;
            display: flex;
            z-index: 1;
        }

        .action-button {
            height: 100%;
            width: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
        }

        /* 팝업 애니메이션 */
        .popup-hidden {
            opacity: 0;
            transform: scale(0.95) translateY(10px);
            transition: all 0.2s ease-out;
            pointer-events: none;
        }

        .popup-visible {
            opacity: 1;
            transform: scale(1) translateY(0);
            transition: all 0.2s ease-in;
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <div id="overlay" class="fixed inset-0 bg-black bg-opacity-20 z-40 hidden transition-opacity duration-300"></div>

    <div id="toast" class="fixed top-20 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-[70] pointer-events-none">
        <p id="toast-message"></p>
    </div>

    <div class="h-full flex flex-col">
        <header class="text-center p-4 border-b border-gray-200">
            <h1 class="text-xl font-bold text-center">캘린더</h1>
        </header>

        <main class="flex-1 overflow-y-auto">
            <div class="max-w-lg mx-auto p-4 lg:max-w-screen-xl lg:pt-4">
                <div class="lg:grid lg:grid-cols-5 lg:gap-8">
                    <div class="lg:col-span-2">
                        <div class="flex flex-col items-center">
                            <div class="flex items-center justify-between w-full mb-4 lg:mb-4">
                                <button id="monthYearBtn"class="text-lg font-semibold cursor-pointer p-2 rounded-md hover:bg-gray-100"></button>
                                <div class="flex space-x-2">
                                    <button id="prevMonth" class="text-gray-500 p-2 rounded-full hover:bg-gray-200">
                                        <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                                        </svg>
                                    </button>
                                    <button id="nextMonth" class="text-gray-500 p-2 rounded-full hover:bg-gray-200">
                                        <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="grid grid-cols-7 text-center text-sm font-medium text-gray-400 w-full lg:mb-2">
                                <span>일</span><span>월</span><span>화</span><span>수</span><span>목</span><span>금</span><span>토</span>
                            </div>
                            <div id="calendarGrid" class="grid grid-cols-7 justify-items-center w-full mt-2 gap-y-2">
                            </div>
                        </div>
                    </div>

                    <hr class="w-full mt-6 mb-4 border-gray-300 lg:hidden">

                    <div class="lg:col-span-3">
                        <div class="space-y-4">
                            <h2 class="py-2 lg:mb-4 text-lg font-bold">예약 현황</h2>
                            <div id="reservationsContainer" class="space-y-4"></div>
                            <button id="add-reservation-btn"
                                class="w-full flex items-center justify-center p-3 mt-4 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 transition-colors">
                                <svg class="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                                </svg>
                                <span>새 예약 추가</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="monthYearModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-xs">
            <h3 class="text-lg font-bold mb-4 text-center">년도 및 월 선택</h3>
            <div class="flex justify-between items-center">
                <button id="prevYear" class="text-gray-500 hover:bg-gray-200 p-2 rounded-full">
                    <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <span id="modalYear" class="font-bold"></span>
                <button id="nextYear" class="text-gray-500 hover:bg-gray-200 p-2 rounded-full">
                    <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                    </svg>
                </button>
            </div>
            <div id="monthSelector" class="grid grid-cols-3 gap-2 mt-4"></div>
        </div>
    </div>

    <!-- 예약 바텀시트 -->
    <div id="reservation-modal" class="fixed inset-0 z-50 hidden flex justify-center items-end pointer-events-none">
        <div id="bottom-sheet"
            class="bg-white w-full max-w-lg rounded-t-2xl p-4 transition-transform duration-300 ease-in-out transform translate-y-full pointer-events-auto">
            <div class="w-full flex justify-center mb-4">
                <div class="w-10 h-1 bg-gray-300 rounded-full"></div>
            </div>
            <h3 id="reservation-date-title" class="text-xl font-bold text-center mb-6"></h3>
            
            <div class="mb-6">
                <label for="restaurant-search-input" class="font-semibold mb-3 text-gray-700 block">식당 이름</label>
                <input type="search" id="restaurant-search-input" placeholder="식당 이름으로 검색" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-400">
                <div id="search-results-container" class="max-h-48 overflow-y-auto border border-gray-200 rounded-lg mt-2 hidden">
                </div>
            </div>
            <div class="mb-6">
                <p class="font-semibold mb-3 text-gray-700">시간</p>
                <div class="h-40 relative flex justify-center items-center gap-4 overflow-hidden">
                    <div class="absolute inset-x-0 h-10 top-1/2 -translate-y-1/2 bg-gray-100 rounded-lg z-0"></div>
                    <div id="hours-selector"
                        class="h-full overflow-y-scroll scroll-snap-y-mandatory scrollbar-hide text-2xl font-medium text-gray-700">
                    </div>
                    <span class="text-2xl font-semibold text-gray-700 z-10">:</span>
                    <div id="minutes-selector"
                        class="h-full overflow-y-scroll scroll-snap-y-mandatory scrollbar-hide text-2xl font-medium text-gray-700">
                    </div>
                </div>
            </div>
            <div class="mb-8">
                <p class="font-semibold mb-3 text-gray-700">인원</p>
                <div id="people-selector" class="grid grid-cols-6 gap-3"></div>
            </div>
            <button id="confirm-reservation-btn"
                class="w-full bg-custom-point text-white font-bold py-4 rounded-xl hover:bg-orange-600">저장</button>
        </div>
    </div>

    <footer class="fixed bottom-0 left-0 right-0 z-30">
        <nav
            class="flex justify-around items-center h-16 bg-white rounded-t-2xl shadow-[0_-2px_10px_rgba(0,0,0,0.05)] max-w-screen-xl mx-auto">
            <a href="home.html"
                class="flex flex-col items-center justify-center w-1/5 h-full text-gray-500 hover:text-[#FF7242] text-xs">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
                <span class="mt-1">홈</span>
            </a>
            <a href="#" class="flex flex-col items-center justify-center w-1/5 h-full text-[#FF7242] text-xs">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor"
                    stroke-width="1.5">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                <span class="font-bold mt-1">캘린더</span>
            </a>
            <div class="w-1/5"></div>
            <a href="scrap.index.html"
                class="flex flex-col items-center justify-center w-1/5 h-full text-gray-500 hover:text-[#FF7242] text-xs">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                </svg>
                <span class="mt-1">스크랩</span>
            </a>
            <a href="mypage.index.html"
                class="flex flex-col items-center justify-center w-1/5 h-full text-gray-500 hover:text-[#FF7242] text-xs">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
                <span class="mt-1">마이</span>
            </a>
        </nav>
    </footer>

    <button id="add-chat-btn"
        class="fixed bottom-6 left-1/2 -translate-x-1/2 w-16 h-16 bg-[#FF7242] hover:bg-orange-600 text-white rounded-full flex items-center justify-center shadow-lg z-40">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </button>

    <div id="add-chat-popup" class="absolute bottom-24 left-1/2 -translate-x-1/2 w-48 bg-white rounded-md shadow-xl z-50 popup-hidden">
        <div class="py-2">
            <a href="chat_list.html" class="flex items-center gap-3 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <line x1="8" y1="6" x2="21" y2="6"></line>
                    <line x1="8" y1="12" x2="21" y2="12"></line>
                    <line x1="8" y1="18" x2="21" y2="18"></line>
                    <line x1="3" y1="6" x2="3.01" y2="6"></line>
                    <line x1="3" y1="12" x2="3.01" y2="12"></line>
                    <line x1="3" y1="18" x2="3.01" y2="18"></line>
                </svg>
                채팅 목록
            </a>
            <a href="chat.html" class="flex items-center gap-3 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" />
                    <circle cx="9" cy="7" r="4" />
                </svg>
                1:1 채팅방
            </a>
            <a href="chat_group.html" class="flex items-center gap-3 px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" />
                    <path d="M18 21v-2a4 4 0 0 0-4-4h-1" />
                    <circle cx="9" cy="7" r="4" />
                    <path d="M18 7h3a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1h-3" />
                    <path d="m15.5 13.5-3-3 3-3" />
                </svg>
                단체 채팅방
            </a>
        </div>
    </div>

    <a href="chat.html" id="secondary-action-btn"
        class="fixed bottom-20 right-6 w-16 h-16 bg-[#FFF6E2] hover:bg-orange-600 text-white rounded-full flex items-center justify-center shadow-lg transition-transform transform hover:scale-110 z-40"
        style="background-image: url('logo_bapick.png'); background-size: 132%; background-repeat: no-repeat; background-position: center 0.5%;">
    </a>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { firebaseConfig } from "./firebase-config.js";

        // -----------------------------------------------------------
        // 초기 설정 및 전역 변수
        // -----------------------------------------------------------
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);

        const fastapiUrl = "https://bapick.duckdns.org"

        let currentUser = null; 
        let searchTimer = null;
        let currentDate = new Date();
        let selectedDate = new Date(); // 선택 날짜를 오늘로 설정
        let selectedRestaurantId = null;
        let toastTimeout;
        let editingReservationId = null; 
        let currentDayReservations = []; 
        let swipeState = { startX: 0, currentX: 0, isDragging: false, swipedElement: null };

        // DOM 요소
        const overlay = document.getElementById('overlay');
        const addChatBtn = document.getElementById('add-chat-btn');
        const addChatPopup = document.getElementById('add-chat-popup');
        const addReservationBtn = document.getElementById('add-reservation-btn');
        const currentMonthYearEl = document.getElementById('monthYearBtn');
        const calendarGridEl = document.getElementById('calendarGrid');
        const prevMonthBtn = document.getElementById('prevMonth');
        const nextMonthBtn = document.getElementById('nextMonth');
        const reservationsContainer = document.getElementById('reservationsContainer');
        const monthYearModal = document.getElementById('monthYearModal');
        const monthSelector = document.getElementById('monthSelector');
        const prevYearBtn = document.getElementById('prevYear');
        const nextYearBtn = document.getElementById('nextYear');
        const modalYearEl = document.getElementById('modalYear');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toast-message');
        const reservationModal = document.getElementById('reservation-modal');
        const bottomSheet = document.getElementById('bottom-sheet');
        const reservationDateTitle = document.getElementById('reservation-date-title');
        const peopleSelector = document.getElementById('people-selector');
        const confirmReservationBtn = document.getElementById('confirm-reservation-btn');
        const restaurantSearchInput = document.getElementById('restaurant-search-input');
        const searchResultsContainer = document.getElementById('search-results-container');


        // -----------------------------------------------------------
        // 유틸리티 함수
        // -----------------------------------------------------------
        // Date 객체를 'YYYY-MM-DD' 형식의 문자열로 변환
        function formatDateToYYYYMMDD(dateObject) {
            if (!(dateObject instanceof Date) || isNaN(dateObject)) {
                return null;
            }
            const year = dateObject.getFullYear();
            const month = String(dateObject.getMonth() + 1).padStart(2, '0');
            const day = String(dateObject.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        const showToast = (message) => {
            clearTimeout(toastTimeout);
            toastMessage.textContent = message;
            toast.classList.remove('opacity-0');
            toastTimeout = setTimeout(() => { toast.classList.add('opacity-0'); }, 2000);
        }

        const closeAllPopups = () => {
            overlay.classList.add('hidden');
            addChatPopup.classList.remove('popup-visible');
            addChatPopup.classList.add('popup-hidden');
            monthYearModal.classList.add('hidden');
            closeReservationModal();
        };

        const closeReservationModal = () => {
            bottomSheet.classList.add('translate-y-full');
            setTimeout(() => {
                reservationModal.classList.add('hidden');
                if (!addChatPopup.classList.contains('popup-visible')) {
                    overlay.classList.add('hidden');
                }
            }, 300);
        };

        // 선택된 시:분을 문자열로 가져옴 
        const getSelectedTime = () => {
            const itemHeight = 40;
            const hoursSelector = document.getElementById('hours-selector');
            const minutesSelector = document.getElementById('minutes-selector');

            const hourIndex = Math.round(hoursSelector.scrollTop / itemHeight);
            const minuteIndex = Math.round(minutesSelector.scrollTop / itemHeight);
            
            const selectedHour = (hourIndex <= 0 ? 0 : hourIndex - 1).toString().padStart(2, '0');
            const selectedMinute = ((minuteIndex <= 0 ? 0 : minuteIndex - 1) * 5).toString().padStart(2, '0');
            
            return `${selectedHour}:${selectedMinute}`;
        };

        // 인원/월 등 버튼 클릭 시 상태 업데이트
        const handleSelection = (container, clickedButton) => {
            container.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('bg-custom-point', 'text-white');
                btn.classList.add('bg-gray-100');
            });
            clickedButton.classList.add('bg-custom-point', 'text-white');
            clickedButton.classList.remove('bg-gray-100');
        };


        // -----------------------------------------------------------
        // API 통신
        // -----------------------------------------------------------
        // 특정 날짜의 예약 목록 조회
        const loadReservations = async (date) => {
            if (!date || !currentUser) return [];
            const dateString = formatDateToYYYYMMDD(date);
            const url = `${fastapiUrl}/api/reservations/?target_date=${dateString}`;

            try {
                const idToken = await currentUser.getIdToken();
                const response = await fetch(url, {
                    method: 'GET',
                    headers: { 
                        'Authorization': `Bearer ${idToken}`, 
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({ detail: `HTTP error! status: ${response.status}` }));
                    throw new Error(errorBody.detail || `예약 목록 로드 실패 (Status: ${response.status})`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching reservations:", error);
                showToast(`예약 목록 로드 실패: ${error.message}`);
                return [];
            }
        };

        // 예약 생성 또는 수정 API 호출
        const createOrUpdateReservation = async (reservationData, reservationId = null) => {
            const isUpdate = reservationId !== null;
            const url = isUpdate 
                ? `${fastapiUrl}/api/reservations/${reservationId}` 
                : `${fastapiUrl}/api/reservations/create`;
            const method = isUpdate ? 'PUT' : 'POST';
            
            try {
                const token = await currentUser.getIdToken(); 
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${token}`, 
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(reservationData)
                });

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({ detail: `API 호출 실패 (Status: ${response.status})` }));
                    throw new Error(errorBody.detail || `API 호출 실패 (Status: ${response.status})`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error(`Error ${isUpdate ? 'updating' : 'creating'} reservation:`, error);
                showToast(`${isUpdate ? '예약 수정' : '예약 생성'} 실패: ${error.message}`);
                return null;
            }
        };

        // 예약 삭제 API 호출
        const deleteReservationApi = async (reservationId) => {
            const token = await currentUser.getIdToken(); 
            const url = `${fastapiUrl}/api/reservations/${reservationId}`;
            try {
                const response = await fetch(url, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`, 
                        'Content-Type': 'application/json'
                    }
                });

                if (response.status === 204) {
                    showToast('예약 삭제 완료.');
                    return true;
                } else {
                    const errorBody = await response.json().catch(() => ({ detail: `API 호출 실패 (Status: ${response.status})` }));
                    throw new Error(errorBody.detail || `예약 삭제 실패 (Status: ${response.status})`);
                }
            } catch (error) {
                console.error("Error deleting reservation:", error);
                showToast(`예약 삭제 실패: ${error.message}`);
                return false;
            }
        }

        // 식당 검색 API 호출
        async function searchRestaurants(keyword) {
            searchResultsContainer.innerHTML = '';
            
            if (!keyword.trim()) {
                searchResultsContainer.classList.add('hidden');
                selectedRestaurantId = null;
                return;
            }
            
            searchResultsContainer.classList.remove('hidden');

            try {
                const token = await currentUser.getIdToken(); 
                const url = `${fastapiUrl}/api/restaurants/search?keyword=${encodeURIComponent(keyword)}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`, 
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`식당 검색 API 오류 ${response.status}:`, errorText);
                    searchResultsContainer.innerHTML = `<p class="p-2 text-red-500">검색 서버 오류 (${response.status})가 발생했습니다.</p>`;
                    return;
                }

                const data = await response.json();

                if (data && Array.isArray(data.restaurants)) {
                    renderSearchResults(data.restaurants); 
                } else {
                    console.error("API 응답 구조 오류: 예상된 'restaurants' 배열이 없습니다.", data);
                    searchResultsContainer.innerHTML = `<p class="p-2 text-red-500">검색 결과를 가져오는 데 실패했습니다.</p>`;
                }
            } catch (error) {
                console.error("식당 검색 중 오류 발생:", error);
                searchResultsContainer.innerHTML = `<p class="p-2 text-red-500">검색 결과를 가져오는 데 실패했습니다.</p>`;
            }
        }


        // -----------------------------------------------------------
        // 캘린더, 예약 목록 렌더링
        // -----------------------------------------------------------
        // 캘린더 렌더링 및 선택한 날짜 표시
        const renderCalendar = () => {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            currentMonthYearEl.textContent = `${year}년 ${month + 1}월`;
            calendarGridEl.innerHTML = '';

            const firstDay = new Date(year, month, 1).getDay();
            const lastDate = new Date(year, month + 1, 0).getDate();
            const today = new Date();

            for (let i = 0; i < firstDay; i++) { calendarGridEl.appendChild(document.createElement('div')); }

            for (let date = 1; date <= lastDate; date++) {
                const dayCell = document.createElement('button');
                dayCell.textContent = date;
                dayCell.className = 'w-10 h-10 flex items-center justify-center rounded-full transition-colors text-gray-800 relative';

                const isSelected = selectedDate && date === selectedDate.getDate() && month === selectedDate.getMonth() && year === selectedDate.getFullYear();
                const isToday = date === today.getDate() && month === today.getMonth() && year === today.getFullYear();
                
                if (isSelected) {
                    dayCell.classList.add('bg-custom-point', 'text-white');
                }
                if (isToday) {
                    dayCell.classList.add('border', 'border-custom-today');
                }
                if (!dayCell.classList.contains('bg-custom-point')) {
                    dayCell.classList.add('hover:bg-gray-100');
                }

                dayCell.addEventListener('click', () => {
                    selectedDate = new Date(year, month, date);
                    renderCalendar();
                    renderReservations(selectedDate); 
                });
                calendarGridEl.appendChild(dayCell);
            }
        };

        // 월/년 선택 모달 렌더링
        const renderMonthModal = () => {
            const year = currentDate.getFullYear();
            modalYearEl.textContent = year;
            monthSelector.innerHTML = '';
            const monthNames = ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"];
            monthNames.forEach((name, index) => {
                const monthButton = document.createElement('button');
                monthButton.textContent = name;
                monthButton.className = 'p-2 rounded-lg transition-colors hover:bg-custom-point hover:text-white font-medium';
                if (currentDate.getMonth() === index) { 
                    monthButton.classList.add('bg-custom-point', 'text-white'); 
                    monthButton.classList.remove('hover:bg-custom-point', 'hover:text-white');
                }
                monthButton.addEventListener('click', () => {
                    currentDate.setMonth(index);
                    monthYearModal.classList.add('hidden');
                    renderCalendar();
                    // 월 변경 시 예약 목록은 오늘 날짜로 로드하지 않음
                });
                monthSelector.appendChild(monthButton);
            });
        };

        // 식당 검색 결과 렌더링 및 클릭 이벤트 연결 (식당 클릭 시 해당 식당 저장)
        function renderSearchResults(restaurants) {
            
            if (restaurants.length === 0) {
                searchResultsContainer.innerHTML = `<p class="p-2 text-gray-500 text-sm">일치하는 식당이 없습니다.</p>`;
                searchResultsContainer.classList.remove('hidden');
                return;
            }

            let results = '';
            restaurants.forEach(restaurant => {
                results += `
                    <div class="restaurant-search-item p-2 hover:bg-gray-100 cursor-pointer border-b border-gray-100" 
                        data-id="${restaurant.id}"
                        data-name="${restaurant.name.replace(/"/g, '&quot;')}"
                        data-category="${restaurant.category}">
                        <p class="font-medium">${restaurant.name} <span class="text-xs text-gray-500">(${restaurant.category})</span></p>
                        <p class="text-xs text-gray-600">${restaurant.address || '주소 정보 없음'}</p>
                        <p class="text-xs text-yellow-500">평점: ${restaurant.rating ? restaurant.rating.toFixed(1) : '평점 없음'}</p>
                    </div>
                `;
            });

            searchResultsContainer.innerHTML = results;
            
            document.querySelectorAll('.restaurant-search-item').forEach(item => {
                item.addEventListener('click', handleRestaurantSelection);
            });
            
            searchResultsContainer.classList.remove('hidden');
        }

        // 선택된 날짜의 예약 목록 조회 및 렌더링
        const renderReservations = async (date) => {
            reservationsContainer.innerHTML = '';

            if (!date || !currentUser) {
                reservationsContainer.className = 'flex items-center justify-center min-h-[100px]';
                reservationsContainer.innerHTML = `<p class="text-center text-gray-500">날짜를 선택하여 예약 현황을 확인하세요.</p>`;
                currentDayReservations = []; 
                return;
            }
            
            const fetchedReservations = await loadReservations(date);
            currentDayReservations = fetchedReservations; 

            if (currentDayReservations.length > 0) {
                reservationsContainer.className = 'space-y-4';
                currentDayReservations.forEach((reservation) => {
                    
                    const resDate = new Date(reservation.reservation_date);
                    const resTime = reservation.reservation_time.substring(0, 5); 
                    const resPeople = `${reservation.people_count}명`;
                    const restaurantName = reservation.restaurant_name;
                    const resId = reservation.id;

                    const swipeContainer = document.createElement('div');
                    swipeContainer.className = 'swipe-container';
                    
                    // --- 스와이프 액션 버튼 생성 ---
                    const swipeActions = document.createElement('div');
                    swipeActions.className = 'swipe-actions';

                    const editButton = document.createElement('button');
                    editButton.className = 'action-button';
                    editButton.style.backgroundColor = '#6b7280';
                    editButton.innerHTML = `<svg class="h-5 w-5 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg><span>수정</span>`;
                    editButton.onclick = () => openReservationModalForEdit(resId);

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'action-button';
                    deleteButton.style.backgroundColor = '#ef4444';
                    deleteButton.innerHTML = `<svg class="h-5 w-5 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg><span>삭제</span>`;
                    deleteButton.onclick = async () => {
                        const success = await deleteReservationApi(resId);
                        if (success) {
                            // 삭제 성공 시 카드 애니메이션
                            swipeContainer.style.transition = 'all 0.3s ease';
                            swipeContainer.style.height = '0px';
                            swipeContainer.style.opacity = '0';
                            swipeContainer.style.padding = '0';
                            swipeContainer.style.margin = '0';
                            setTimeout(() => {
                                renderReservations(selectedDate); 
                                renderCalendar(); 
                            }, 300);
                        }
                    };
                    
                    swipeActions.appendChild(editButton);
                    swipeActions.appendChild(deleteButton);

                    // --- 예약 카드 콘텐츠 생성 ---
                    const reservationCard = document.createElement('div');
                    reservationCard.className = 'swipe-content p-4 shadow-md flex items-center space-x-4';
                    reservationCard.innerHTML = `
                    <div class="rounded-lg w-12 h-12 flex items-center justify-center text-white font-bold text-xl" style="background-color: #FDBF50;">${resDate.getDate()}</div>
                    <div class="flex-1 text-gray-800">
                        <p class="text-lg font-semibold">${restaurantName}</p>
                        <p class="text-sm font-medium mt-1">${resTime} / ${resPeople}</p>
                    </div>`;
                    
                    swipeContainer.appendChild(swipeActions);
                    swipeContainer.appendChild(reservationCard);
                    reservationsContainer.appendChild(swipeContainer);
                    
                    // 스와이프 리스너 추가
                    addSwipeListeners(reservationCard);
                });
            } else {
                reservationsContainer.className = 'flex items-center justify-center min-h-[100px]';
                reservationsContainer.innerHTML = `<p class="text-center text-gray-500">선택한 날짜에 예약이 없습니다.</p>`;
            }
        };


        // -----------------------------------------------------------
        // 모달 UI 조작 및 이벤트 처리 함수
        // -----------------------------------------------------------
        // 스와이프 동작 리스너를 예약 카드에 추가
        // -----------------------------------------------------------
        // [수정됨] 스와이프 동작 리스너 (터치 + 마우스 지원)
        // -----------------------------------------------------------
        function addSwipeListeners(element) {
            let startX, currentX = 0, initialTransform = 0;
            const swipeThreshold = 50;
            let isMouseDown = false; // 마우스 클릭 상태 확인용

            // 공통 로직: 드래그 시작
            const handleStart = (clientX) => {
                startX = clientX;
                // 현재 transform 값 파싱 (없으면 0)
                const transformMatch = element.style.transform.match(/translateX\(([-\d.]+)px\)/);
                initialTransform = transformMatch ? parseFloat(transformMatch[1]) : 0;
                
                element.style.transition = 'none'; // 드래그 중엔 애니메이션 끄기
                swipeState.isDragging = true;
                swipeState.swipedElement = element;

                // 다른 열려있는 카드들 닫기
                document.querySelectorAll('.swipe-content').forEach(other => {
                    if (other !== element) {
                        other.style.transform = 'translateX(0px)';
                        other.style.transition = 'transform 0.3s ease';
                    }
                });
            };

            // 공통 로직: 드래그 중
            const handleMove = (clientX) => {
                if (!swipeState.isDragging || swipeState.swipedElement !== element) return;
                
                currentX = clientX;
                const diff = currentX - startX;
                // -160px (버튼 영역) ~ 0px 사이로 제한
                // 마우스로 오른쪽으로 끄는 건 막음 (Math.min(0, ...))
                const newTransform = Math.max(-160, Math.min(0, diff + initialTransform));
                element.style.transform = `translateX(${newTransform}px)`;
            };

            // 공통 로직: 드래그 종료
            const handleEnd = () => {
                if (!swipeState.isDragging || swipeState.swipedElement !== element) return;
                
                swipeState.isDragging = false;
                swipeState.swipedElement = null;
                element.style.transition = 'transform 0.3s ease'; // 애니메이션 다시 켜기

                // 현재 위치 확인
                const transformMatch = element.style.transform.match(/translateX\(([-\d.]+)px\)/);
                const currentTransform = transformMatch ? parseFloat(transformMatch[1]) : 0;

                // 임계값(-50px)보다 더 왼쪽으로 갔으면 버튼 열기(-160px), 아니면 닫기(0px)
                if (currentTransform < -swipeThreshold) {
                    element.style.transform = 'translateX(-160px)';
                } else {
                    element.style.transform = 'translateX(0px)';
                }
            };

            // --- 터치 이벤트 리스너 ---
            element.addEventListener('touchstart', (e) => handleStart(e.touches[0].clientX));
            element.addEventListener('touchmove', (e) => handleMove(e.touches[0].clientX));
            element.addEventListener('touchend', handleEnd);

            // --- [추가됨] 마우스 이벤트 리스너 ---
            element.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                handleStart(e.clientX);
            });

            // 마우스는 element 밖으로 나가도 드래그가 끊기면 안 되므로 window에 붙임
            window.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    e.preventDefault(); // 텍스트 선택 방지
                    handleMove(e.clientX);
                }
            });

            window.addEventListener('mouseup', () => {
                if (isMouseDown) {
                    isMouseDown = false;
                    handleEnd();
                }
            });
            
            // 이미지/텍스트 드래그 방지 (PC에서 필수)
            element.ondragstart = () => false;
        }

        // 시간 선택 UI
        const populateTimePicker = () => {
            const hoursSelector = document.getElementById('hours-selector');
            const minutesSelector = document.getElementById('minutes-selector');
            hoursSelector.innerHTML = ''; minutesSelector.innerHTML = '';
            const itemHeight = 40;
            const paddingElHeight = `calc(50% - ${itemHeight / 2}px)`;

            const createPadding = () => {
                const padding = document.createElement('div');
                padding.style.height = paddingElHeight;
                return padding;
            };

            // 시간 (00시 ~ 23시)
            hoursSelector.appendChild(createPadding());
            for (let i = 0; i <= 23; i++) {
                const hour = document.createElement('div');
                hour.textContent = i.toString().padStart(2, '0');
                hour.className = 'h-10 flex items-center justify-center scroll-snap-align-center opacity-50 transition-all duration-150';
                hoursSelector.appendChild(hour);
            }
            hoursSelector.appendChild(createPadding());

            // 분 (00분 ~ 55분, 5분 단위)
            minutesSelector.appendChild(createPadding());
            for (let i = 0; i < 60; i += 5) {
                const minute = document.createElement('div');
                minute.textContent = i.toString().padStart(2, '0');
                minute.className = 'h-10 flex items-center justify-center scroll-snap-align-center opacity-50 transition-all duration-150';
                minutesSelector.appendChild(minute);
            }
            minutesSelector.appendChild(createPadding());

            // 스크롤 위치에 따라 중앙 항목 활성화
            const updateActive = (container) => {
                const centerScroll = container.scrollTop + container.clientHeight / 2;
                const centerIndex = Math.round(container.scrollTop / itemHeight);
                
                Array.from(container.children).forEach((child, index) => {
                    const itemIndex = index - 1; // 패딩 고려

                    if (itemIndex === centerIndex) {
                        child.classList.remove('opacity-50', 'scale-90');
                        child.classList.add('opacity-100', 'scale-100', 'font-bold');
                    } else {
                        child.classList.add('opacity-50', 'scale-90');
                        child.classList.remove('opacity-100', 'scale-100', 'font-bold');
                    }
                });
            };
            
            // 스크롤 이벤트 리스너 (디바운싱 적용)
            let scrollTimeout;
            const handleScroll = (container) => { 
                clearTimeout(scrollTimeout); 
                scrollTimeout = setTimeout(() => updateActive(container), 150); 
            };

            hoursSelector.addEventListener('scroll', () => handleScroll(hoursSelector));
            minutesSelector.addEventListener('scroll', () => handleScroll(minutesSelector));
            
            // 초기 활성화 상태 설정
            setTimeout(() => { updateActive(hoursSelector); updateActive(minutesSelector); }, 50);
        };

        // 인원 선택 버튼 UI
        const populatePeopleCount = () => {
            peopleSelector.innerHTML = '';
            for (let i = 1; i <= 6; i++) {
                const button = document.createElement('button');
                button.textContent = `${i}명`;
                button.className = 'p-3 rounded-lg font-medium bg-gray-100 hover:bg-gray-200 transition-colors';
                button.addEventListener('click', () => handleSelection(peopleSelector, button));
                peopleSelector.appendChild(button);
            }
            // 기본값 2명 선택
            handleSelection(peopleSelector, peopleSelector.children[1]); 
        };

        // 검색 결과에서 식당 선택 시 해당 식당 저장
        function handleRestaurantSelection(event) {
            const item = event.currentTarget;
            
            const restaurantId = parseInt(item.dataset.id, 10); 
            const restaurantName = item.dataset.name;
            
            selectedRestaurantId = restaurantId;
            
            restaurantSearchInput.value = restaurantName;
            
            searchResultsContainer.classList.add('hidden');
            searchResultsContainer.innerHTML = '';
        }

        // 팝업 시트
        const _openReservationModalUI = () => {
            const options = { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' };
            reservationDateTitle.textContent = selectedDate.toLocaleString('ko-KR', options);
            overlay.classList.remove('hidden');
            reservationModal.classList.remove('hidden');
            setTimeout(() => { bottomSheet.classList.remove('translate-y-full'); }, 10);
        };

        // 새 예약을 위한 예약 모델 
        const openReservationModalForCreate = () => {
            if (!selectedDate) {
                showToast('날짜를 먼저 선택해주세요.');
                return;
            }
            editingReservationId = null;
            confirmReservationBtn.textContent = '저장';
            selectedRestaurantId = null;
            
            restaurantSearchInput.value = '';
            searchResultsContainer.innerHTML = '';
            searchResultsContainer.classList.add('hidden');

            populateTimePicker();
            populatePeopleCount();
            _openReservationModalUI();
        };

        // 기존 예약을 수정하기 위한 예약 모달
        const openReservationModalForEdit = (reservationId) => {
            const reservation = currentDayReservations.find(r => r.id === reservationId);

            if (!reservation) {
                showToast('수정할 예약을 찾을 수 없습니다.');
                return;
            }
            
            editingReservationId = reservationId;
            confirmReservationBtn.textContent = '수정 저장';
            selectedDate = new Date(reservation.reservation_date);
            selectedRestaurantId = reservation.restaurant_id;
            
            restaurantSearchInput.value = reservation.restaurant_name;
            searchResultsContainer.innerHTML = '';
            searchResultsContainer.classList.add('hidden');

            populateTimePicker();
            populatePeopleCount();
            
            // 인원 버튼 선택 상태 업데이트
            peopleSelector.querySelectorAll('button').forEach(btn => {
                if (btn.textContent === `${reservation.people_count}명`) { 
                    handleSelection(peopleSelector, btn); 
                }
            });

            _openReservationModalUI();
            
            // 시간 선택기 스크롤 위치 조정
            setTimeout(() => {
                const [hour, minute] = reservation.reservation_time.substring(0, 5).split(':').map(Number);
                const itemHeight = 40;
                
                // 패딩 고려하여 스크롤 위치 조정
                document.getElementById('hours-selector').scrollTop = (hour + 1) * itemHeight;
                document.getElementById('minutes-selector').scrollTop = (minute / 5 + 1) * itemHeight;
                
                // 활성화 상태 강제 업데이트
                const updateActive = (container) => {
                    const centerIndex = Math.round(container.scrollTop / itemHeight);
                    Array.from(container.children).forEach((child, index) => {
                        const itemIndex = index - 1;
                        if (itemIndex === centerIndex) {
                            child.classList.remove('opacity-50', 'scale-90');
                            child.classList.add('opacity-100', 'scale-100', 'font-bold');
                        } else {
                            child.classList.add('opacity-50', 'scale-90');
                            child.classList.remove('opacity-100', 'scale-100', 'font-bold');
                        }
                    });
                };
                updateActive(document.getElementById('hours-selector'));
                updateActive(document.getElementById('minutes-selector'));
                
            }, 350); // 모달 애니메이션 완료 후 실행
        };


        // -----------------------------------------------------------
        // 이벤트 리스너 등록 및 초기 실행
        // -----------------------------------------------------------
        // Firebase 인증 상태
        onAuthStateChanged(auth, (user) => {
            currentUser = user
            if (user) {
                renderReservations(selectedDate);
            } else {
                renderReservations(null);
                showToast('로그인을 하지 않았습니다.');
                window.location.href = 'index.html';
            }
        });

        // 채팅 팝업 토글
        addChatBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const isAddChatOpen = addChatPopup.classList.contains('popup-visible');
            closeAllPopups();
            if (!isAddChatOpen) {
                overlay.classList.remove('hidden');
                addChatPopup.classList.remove('popup-hidden');
                addChatPopup.classList.add('popup-visible');
            }
        });

        // 오버레이 클릭 시 팝업 닫기
        overlay.addEventListener('click', closeAllPopups);
        reservationModal.addEventListener('click', (e) => { if (e.target === reservationModal) closeReservationModal(); });

        // 예약 추가 버튼
        addReservationBtn.addEventListener('click', openReservationModalForCreate);

        // 캘린더 이동 및 모달
        currentMonthYearEl.addEventListener('click', () => { renderMonthModal(); monthYearModal.classList.remove('hidden'); });
        monthYearModal.addEventListener('click', (e) => { if (e.target === monthYearModal) monthYearModal.classList.add('hidden'); });
        prevYearBtn.addEventListener('click', () => { currentDate.setFullYear(currentDate.getFullYear() - 1); renderMonthModal(); });
        nextYearBtn.addEventListener('click', () => { currentDate.setFullYear(currentDate.getFullYear() + 1); renderMonthModal(); });
        prevMonthBtn.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() - 1); renderCalendar(); renderReservations(selectedDate); });
        nextMonthBtn.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() + 1); renderCalendar(); renderReservations(selectedDate); });

        // 식당 검색 입력 처리 (디바운싱)
        restaurantSearchInput.addEventListener('input', function() {
            clearTimeout(searchTimer);
            const keyword = this.value;

            if (keyword.length > 0) {
                searchTimer = setTimeout(() => {
                    searchRestaurants(keyword);
                }, 300);
            } else {
                searchResultsContainer.innerHTML = '';
                searchResultsContainer.classList.add('hidden');
                selectedRestaurantId = null;
            }
        });

        // 예약 생성/수정 확정 버튼
        confirmReservationBtn.addEventListener('click', async () => {
            const restaurantName = restaurantSearchInput.value;
            const restaurantId = selectedRestaurantId;

            if (!restaurantId || typeof restaurantId !== 'number' || restaurantId <= 0) {
                console.error("유효한 식당 ID가 선택되지 않았습니다.");
                showToast(`${restaurantName}' 맛집을 검색 결과 목록에서 클릭해주세요.`); 
                return;
            }

            const selectedTime = getSelectedTime();
            const selectedPeopleEl = peopleSelector.querySelector('.bg-custom-point');
            if (!selectedPeopleEl) { showToast('인원을 선택해주세요.'); return; }

            const peopleCount = parseInt(selectedPeopleEl.textContent.replace('명', ''), 10);

            const reservationData = {
                restaurant_id: restaurantId,
                reservation_date: formatDateToYYYYMMDD(selectedDate),
                reservation_time: `${selectedTime}:00`, 
                people_count: peopleCount
            };

            let result;
            if (editingReservationId !== null) {
                result = await createOrUpdateReservation(reservationData, editingReservationId);
            } else {
                result = await createOrUpdateReservation(reservationData);
            }
            
            if (result) {
                editingReservationId = null;
                await renderReservations(selectedDate); 
                closeReservationModal();
                renderCalendar();
            }
        });

        renderCalendar();
    </script>
</body>

</html>